# 1 日志记录方法执行

作用在方法上，当请求接口时在日志中打印出方法的执行，形如：

```
执行方法: com.ling.controller.TestController.test(), 参数: []
```

## 1.1 @LogMethodExecute

注解如下：

```java
package com.ling.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 日志记录方法执行
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogMethodExecute {
    boolean enable() default true;
}

```

`enable`：是否启用日志记录方法执行。

## 1.2 切面实现

```java
package com.ling.aspect;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ling.annotation.LogMethodExecute;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.lang.reflect.Method;

/**
 * 日志记录方法执行切面
 */
@Aspect
@Component
@Order(2)
public class LogMethodExecuteAspect {
    private Logger log = LoggerFactory.getLogger(LogMethodExecuteAspect.class);

    @Resource
    private ObjectMapper objectMapper;

    @Pointcut("@annotation(com.ling.annotation.LogMethodExecute)")
    public void pt() {

    }

    @Before("pt()")
    public void logMethodExecute(JoinPoint joinPoint) {
        try {
            Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
            LogMethodExecute lme = method.getAnnotation(LogMethodExecute.class);
            String classname = joinPoint.getTarget().getClass().getName();
            if (lme == null || !lme.enable()) return;
            Object[] args = joinPoint.getArgs();
            // 序列化深层对象
            String argsStr = objectMapper.writer().writeValueAsString(args);
            log.info("执行方法: {}.{}(), 参数: {}", classname, method.getName(), argsStr);
        } catch (Exception e) {
            log.error("记录方法执行日志时发生异常: {}", e.getMessage(), e);
        }
    }
}
```

`ObjectMapper` 是 Jackson 提供的类，支持对对象进行深层次的序列化。当对象的属性中嵌套了其他对象时，普通的打印方法无法完整显示其内部结构，而 `ObjectMapper` 可以将其序列化为 JSON 格式，清晰地展现嵌套内容。

## 1.3 执行顺序

在应用中同时使用 **参数校验注解** 和 **日志记录注解** 时，**参数校验注解** 应该优先执行：

- **校验先行**：如果方法参数不合法，业务逻辑不应该继续执行。因此，校验注解的优先级应高于日志记录注解。

- **避免无效日志**：如果在日志记录注解中打印了参数信息，而后续的参数校验抛出异常，就会导致日志中记录了无效的调用信息。

用`@Order`来控制 **参数校验注解** 和 **日志记录注解** 的执行顺序。