# 

本章提供常用的实体，和基础的CRUD操作、涵盖controller、service、mappers三层，以及对应的mapper.xml文件，以完成项目中对一个实体表的基础操作。

其中，mapper接口包含以下方法：

- 【select()】，查询，包含条件分页查询功能。
- 【selectById()】，通过id查询。
- 【insert()】，插入。
- 【batchInsert()】，批量插入。
- 【update()】，修改
- 【delete()】，删除和批量删除。

方法名根据同sql语句名相似。

service接口方法如下：

- 【find()】，对应【select()】。
- 【findById()】，对应【selectById()】。
- 【add()】，对应【insert()】。
- 【batchAdd()】，对应【batchInsert()】。
- 【edit()】，对应【update()】。
- 【delete()】，对应【delete()】。

下面将以book作为示例，使用时将属性替换成实际实体表的字段。一般只改动pojo和对应query即可。

# 1 常用实体

## 1.1 pojo

日期采用【Date】老版本的时间对象，而非新版本的时间对象，通过【@JsonFormat】处理格式化。

```java
@Data
@NoArgsConstructor
public class Book {
    private Integer id;
    private String name;
    private String cover;
    private String author;
    private String publish;
    @JsonFormat(pattern = "yyyy-MM-dd", timezone = "GMT+8")
    private Date publishDate;
    private Integer bookTypeId;
    private String description;
    private Integer number;
    @JsonFormat(pattern = "yyyy-MM-dd hh:mm:ss", timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern = "yyyy-MM-dd hh:mm:ss", timezone = "GMT+8")
    private Date updateTime;
}
```

## 1.2 query实体

pojo的字段本身就可以作为条件，但是它的字段不一定会用于条件查询，比如日期字段，需要查询介于起始日期和结束日期之间时，起始日期和结束日期，pojo中是没有这个字段的，另外分页查询的字段pojo也是没有的，因此定义一个条件查询实体来封装查询条件。

继承至pojo，这样能继承它的字段。

【@EqualsAndHashCode】是lombok的注解，表示子类中【equals()】和【hashCode()】对于继承自父类的字段，采用父类中的逻辑。

```java
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
public class BookQuery extends Book {
    private Integer page = 1;
    private Integer pageSize = 10;
    private Integer start;
    private Date startDate;
    private Date endDate;
}
```

## 1.3 pageBean

分页数据实体，封装分页后的数据。

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageBean<T> {
    private Long total;         // 总记录数
    private Integer page;       // 当前页码
    private Integer pageSize;   // 每页显示条数
    private Integer pageTotal;  // 总页数
    private List<T> rows;       // 当前页数据

    public PageBean(Long total, List<T> rows) {
        this.total = total;
        this.rows = rows;
    }

    public static <T> PageBean<T> of(Long total, List<T> rows) {
        return new PageBean<>(total, rows);
    }

    public static <T> PageBean<T> of(Long total, Integer page, Integer pageSize, Integer pageTotal,
                                     List<T> rows) {
        return new PageBean<>(total, page, pageSize, pageTotal, rows);
```

## 1.4 响应结果、异常、响应状态码实体

响应结果和异常依赖响应状态码，响应状态码是预先定义好的枚举，异常会记录响应状态码，可以在全局异常处理器中传递给响应结果。响应结果在正常响应时，也需要响应状态码。

### 1.4.1 响应状态码

枚举项按需增加：

```java
public enum ResponseCodeEnum {
    CODE_200(200, "请求成功"),
    CODE_404(404, "请求地址不存在"),
    CODE_600(600, "请求参数错误"),
    CODE_601(601, "信息已存在"),
    COED_700(700, "业务异常"),
    CODE_500(500, "服务器返回错误，请联系管理员");

    private Integer code;

    private String msg;

    ResponseCodeEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
```

### 1.4.2 异常

自定义异常，处理业务异常：

```java
public class BusinessException extends RuntimeException {
    private Integer code;
    private String msg;
    private ResponseCodeEnum codeEnum;
	
    /**
     * code和msg构建异常
     * @param code
     * @param msg
     */
    public BusinessException(Integer code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    /**
     * 业务异常，code用响应状态码枚举业务异常的状态码
     * @param msg
     */
    public BusinessException(String msg) {
        super(msg);
        this.code = ResponseCodeEnum.COED_700.getCode();
        this.msg = msg;
    }

    /**
     * 响应状态码枚举构建异常
     * @param codeEnum
     */
    public BusinessException(ResponseCodeEnum codeEnum) {
        super(codeEnum.getMsg());
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.codeEnum = codeEnum;
    }

    /**
     * 响应状态码枚举和异常构建异常
     * @param codeEnum
     * @param e
     */
    public BusinessException(ResponseCodeEnum codeEnum, Throwable e) {
        super(codeEnum.getMsg(), e);
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.codeEnum = codeEnum;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public ResponseCodeEnum getCodeEnum() {
        return codeEnum;
    }

    /**
     * 业务异常不需要打印堆栈信息，提高效率
     *
     * @return
     */
    @Override
    public Throwable fillInStackTrace() {
        return this;
    }
}
```

### 1.4.3 响应结果

```java
public class Result<T> {
    private String status;
    private Integer code;
    private String msg;
    private T data;

    private String status;
    private Integer code;
    private String msg;
    private T data;

    public Result(String status, ResponseCodeEnum codeEnum, T data) {
        this.status = status;
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.data = data;
    }

    public Result(String status, Integer code, String msg, T data) {
        this.status = status;
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    /**
     * 成功结果，返回200，带数据
     * @param data
     * @return
     * @param <T>
     */
    public static <T> Result<T> success(T data) {
        return new Result<>("success", ResponseCodeEnum.CODE_200, data);
    }

    /**
     * 成功响应，返回200，不带数据
     * @return
     */
    public static Result success() {
        return new Result<>("success", ResponseCodeEnum.CODE_200, null);
    }

    /**
     * 失败结果，通过响应状态码枚举构建
     * @param codeEnum
     * @return
     */
    public static Result error(ResponseCodeEnum codeEnum) {
        return new Result<>("error", codeEnum, null);
    }

    /**
     * 失败结果，通过code和msg构建
     * @param code
     * @param msg
     * @return
     */
    public static Result error(Integer code, String msg) {
        return new Result<>("error", code, msg, null);
    }

    /**
     * 失败结果，通过业务异常构建
     * @param e
     * @return
     */
    public static Result error(BusinessException e) {
        return error(e.getCode(), e.getMsg());
    }

    @Override
    public String toString() {
        return "Result{" +
                "status='" + status + '\'' +
                ", code=" + code +
                ", msg='" + msg + '\'' +
                ", data=" + data +
                '}';
    }

    public String getStatus() {
        return status;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public T getData() {
        return data;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```



# 2 mapper

## 2.1 mapper接口

book对应的mapper接口：

```java
@Mapper
public interface BookMapper {

    /**
     * 查询
     *
     * @param 
     * @return
     */
    List<Book> select(@Param("bookQuery") BookQuery bookQuery);

    /**
     * 根据id查询
     *
     * @param 
     * @return
     */
    Book selectById(int id);

    /**
     * 添加
     *
     * @param 
     */
    void insert(Book book);

    /**
     * 批量添加
     * @param 
     */
    void batchInsert(List<Book> books);

    /**
     * 更新
     *
     * @param 
     */
    void update(Book book);

    /**
     * 删除
     *
     * @param 
     */
    void delete(List<Integer> ids);
}
```

## 2.2 对应的xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ling.mappers.BookMapper">
    <!-- 通用sql -->
    <sql id="commonSelect">
        select id,
               ISBN,
               name,
               cover,
               author,
               publish,
               publish_date,
               book_type_id,
               description,
               number,
               create_time,
               update_time
    </sql>
    
    <!-- 条件分页查询 -->
    <select id="select" resultType="com.ling.entity.book.Book">
        <include refid="commonSelect"/>
        from books
        <where>
            <if test="bookQuery.name != null and bookQuery.name != ''">
                name like concat('%', #{bookQuery.name}, '%')
            </if>
            <if test="bookQuery.author != null and bookQuery.author != ''">
                and author like concat('%', #{bookQuery.author}, '%')
            </if>
            <if test="bookQuery.startDate != null and bookQuery.endDate != null">
                and publish_date between #{bookQuery.startDate} and #{bookQuery.endDate}
            </if>
            <if test="bookQuery.bookTypeId != null">
                and book_type_id = #{bookQuery.bookTypeId}
            </if>
        </where>
    </select>

    <!-- 通过id查询 -->
    <select id="selectById" resultType="com.ling.entity.book.Book">
        <include refid="commonSelect"/>
        from books
        where id = #{id}
    </select>

    <!-- 插入 -->
    <insert id="insert">

    </insert>

    <!-- 批量插入 -->
    <insert id="batchInsert">
        
    </insert>

    <!-- 更新 -->
    <update id="update">

    </update>

    <!-- 删除/批量删除 -->
    <delete id="delete"></delete>
</mapper>
```



# 3 service

## 3.1 接口

```java
public interface BookService {

    /**
     * 条件分页查询
     * @param bookQuery
     * @return
     */
    PageBean<Book> find(BookQuery bookQuery);

    /**
     * 根据id查询
     * @param id
     * @return
     */
    Book findById(Integer id);

    /**
     * 新增
     * @param book
     */
    void add(Book book);

    /**
     * 批量新增
     * @param books
     */
    void batchAdd(List<Book> books);

    /**
     * 修改
     * @param book
     */
    void edit(Book book);

    /**
     * 删除/批量删除
     * @param ids
     */
    void delete(List<Integer> ids);
}
```

## 3.2 实现

分页采用PageHelper插件。

```java
@Service
public class BookServiceImpl implements BookService {
    @Resource
    private BookMapper bookMapper;

    @Override
    public PageBean<Book> find(BookQuery bookQuery) {
        PageHelper.startPage(bookQuery.getPage(), bookQuery.getPageSize());
        List<Book> books = bookMapper.select(bookQuery);
        Page<Book> p = (Page<Book>) books;
        if (bookQuery.getPage() > p.getPages()) throw new BusinessException(ResponseCodeEnum.CODE_600);
        return PageBean.of(p.getTotal(), bookQuery.getPage(), bookQuery.getPageSize(), p.getPages(), p.getResult());
    }

    @Override
    public Book findById(Integer id) {
        return bookMapper.selectById(id);
    }

    @Override
    public void add(Book book) {
        bookMapper.insert(book);
    }

    @Override
    public void batchAdd(List<Book> books) {

    }

    @Override
    public void edit(Book book) {
        bookMapper.update(book);
    }

    @Override
    public void delete(List<Integer> ids) {
        bookMapper.delete(ids);
    }
}
```



# 4 controller

## 4.1 控制器

```java
@RestController
@RequestMapping("/book")
public class BookController {
    @Resource
    private BookService bookService;

    @GetMapping
    public Result<PageBean<Book>> getBookInfo(@RequestBody BookQuery bookQuery) {
        System.out.println(bookQuery);
        PageBean<Book> pageBean = bookService.find(bookQuery);
        return Result.success(pageBean);
    }
}
```

## 4.2 统一异常拦截器

```java
@RestControllerAdvice
public class GlobalExceptionController {
    private Logger log = LoggerFactory.getLogger(GlobalExceptionController.class);

    /**
     * 业务异常
     * @param e
     * @return
     */
    @ExceptionHandler(BusinessException.class)
    public Result businessExceptionHandler(BusinessException e) {
        log.info("异常{}", e.getCode());
        return Result.error(e);
    }

    @ExceptionHandler({MissingServletRequestParameterException.class})
    public Result exceptionHandler(MissingServletRequestParameterException e) {
        log.error("异常{}", e);
        return Result.error(ResponseCodeEnum.CODE_600);
    }

    /**
     * 其他异常
     * @param e
     * @return
     */
    @ExceptionHandler(Exception.class)
    public Result exceptionHandler(Exception e) {
        log.error("异常{}", e);
        return Result.error(ResponseCodeEnum.CODE_500);
    }
}
```

