# 

本章提供常用的实体，和基础的CRUD操作、涵盖controller、service、mappers三层，以及对应的mapper.xml文件，以完成项目中对一个实体表的基础操作。

其中，mapper接口包含以下方法：

- `select()`，查询，包含条件分页查询功能。
- `selectById()`，通过id查询。
- `insert()`，插入。
- `batchInsert()`，批量插入。
- `update()`，修改
- `delete()`，删除和批量删除。

方法名根据同sql语句名相似。

service接口方法如下：

- `find()`，对应`select()`。
- `findById()`，对应`selectById()`。
- `add()`，对应`insert()`。
- `batchAdd()`，对应`batchInsert()`。
- `edit()`，对应`update()`。
- `delete()`，对应`delete()`。

下面将以book作为示例，使用时将属性替换成实际实体表的字段。一般只改动pojo和对应query即可。

# 1 常用实体

## 1.1 pojo

日期采用`Date`老版本的时间对象，而非新版本的时间对象，通过`@JsonFormat`处理格式化。

```java
@Data
@NoArgsConstructor
public class Book {
    private Integer id;
    private String name;
    private String cover;
    private String author;
    private String publish;
    @JsonFormat(pattern = "yyyy-MM-dd", timezone = "GMT+8")
    private Date publishDate;
    private Integer bookTypeId;
    private String description;
    private Integer number;
    @JsonFormat(pattern = "yyyy-MM-dd hh:mm:ss", timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern = "yyyy-MM-dd hh:mm:ss", timezone = "GMT+8")
    private Date updateTime;
}
```

## 1.2 query实体

pojo的字段本身就可以作为条件，但是它的字段不一定会用于条件查询，比如日期字段，需要查询介于起始日期和结束日期之间时，起始日期和结束日期，pojo中是没有这个字段的，另外分页查询的字段pojo也是没有的，因此定义一个条件查询实体来封装查询条件。

继承至pojo，这样能继承它的字段。

`@EqualsAndHashCode`是lombok的注解，表示子类中`equals()`和`hashCode()`对于继承自父类的字段，采用父类中的逻辑。

```java
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
public class BookQuery extends Book {
    private Integer page = 1;
    private Integer pageSize = 10;
    private Integer start;
    private Date startDate;
    private Date endDate;
}
```

## 1.3 pageBean

分页数据实体，封装分页后的数据。

```java
public class PageBean<T> {
    private Long total;         // 总记录数
    private Integer page;       // 当前页码
    private Integer pageSize;   // 每页显示条数
    private Integer pageTotal;  // 总页数
    private List<T> rows;       // 当前页数据

    public PageBean(Long total, List<T> rows) {
        this.total = total;
        this.rows = rows;
    }

    public static <T> PageBean<T> of(Long total, List<T> rows) {
        return new PageBean<>(total, rows);
    }

    public static <T> PageBean<T> of(Long total, Integer page, Integer pageSize, Integer pageTotal,
                                     List<T> rows) {
        return new PageBean<>(total, page, pageSize, pageTotal, rows);
    }

    public PageBean(Long total, Integer page, Integer pageSize, Integer pageTotal, List<T> rows) {
        this.total = total;
        this.page = page;
        this.pageSize = pageSize;
        this.pageTotal = pageTotal;
        this.rows = rows;
    }

    public PageBean() {
    }
}
```

## 1.4 通用消息类

提供通用的消息：

```java
public class CommonMsg {
    public static final String REQUEST_SUCCESS = "请求成功";
    public static final String REQUEST_NOT_FOUND = "请求地址不存在";
    public static final String REQUEST_PARAM_ERROR = "请求参数错误";
    public static final String REQUEST_ALREADY_EXISTS = "信息已存在";
    public static final String BUSINESS_ERROR = "业务异常";
    public static final String SERVER_ERROR = "服务器返回错误，请联系管理员";
    public static final String INVALID_TOKEN = "无效的token";
    public static final String SESSION_EXPIRED = "会话已过期，请重新登录";
    public static final String OPERATION_SUCCESS = "操作成功";
    public static final String OPERATION_FAIL = "操作失败";
    public static final String UPLOAD_SUCCESS = "上传成功";
    public static final String UPLOAD_FAIL = "上传失败";
    public static final String PERMISSION_DENIED = "权限不足";
}
```

## 1.5 响应结果、异常、响应状态码实体

响应结果和异常依赖响应状态码，响应状态码是预先定义好的枚举，异常会记录响应状态码，可以在全局异常处理器中传递给响应结果。响应结果在正常响应时，也需要响应状态码。

### 1.5.1 响应状态码

枚举项按需增加，响应的消息来自通用消息类`CommonMsg`：

```java
public enum ResponseCodeEnum {
    CODE_200(200, CommonMsg.REQUEST_SUCCESS),
    CODE_404(404, CommonMsg.REQUEST_NOT_FOUND),
    CODE_600(600, CommonMsg.REQUEST_PARAM_ERROR),
    CODE_601(601, CommonMsg.REQUEST_ALREADY_EXISTS),
    COED_700(700, CommonMsg.BUSINESS_ERROR),
    CODE_500(500, CommonMsg.SERVER_ERROR);

    private Integer code;

    private String msg;

    ResponseCodeEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
```

### 1.5.2 异常

自定义异常，处理业务异常：

```java
public class BusinessException extends RuntimeException {
    private Integer code;
    private String msg;
    private ResponseCodeEnum codeEnum;
	
    /**
     * code和msg构建异常
     * @param code
     * @param msg
     */
    public BusinessException(Integer code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    /**
     * 业务异常，code用响应状态码枚举业务异常的状态码
     * @param msg
     */
    public BusinessException(String msg) {
        super(msg);
        this.code = ResponseCodeEnum.COED_700.getCode();
        this.msg = msg;
    }

    /**
     * 响应状态码枚举构建异常
     * @param codeEnum
     */
    public BusinessException(ResponseCodeEnum codeEnum) {
        super(codeEnum.getMsg());
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.codeEnum = codeEnum;
    }

    /**
     * 响应状态码枚举和异常构建异常
     * @param codeEnum
     * @param e
     */
    public BusinessException(ResponseCodeEnum codeEnum, Throwable e) {
        super(codeEnum.getMsg(), e);
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.codeEnum = codeEnum;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public ResponseCodeEnum getCodeEnum() {
        return codeEnum;
    }

    /**
     * 业务异常不需要打印堆栈信息，提高效率
     *
     * @return
     */
    @Override
    public Throwable fillInStackTrace() {
        return this;
    }
}
```

### 1.5.3 响应结果

```java
public class Result<T> {

    private String status;
    private Integer code;
    private String msg;
    private T data;

    public Result(String status, ResponseCodeEnum codeEnum, T data) {
        this.status = status;
        code = codeEnum.getCode();
        msg = codeEnum.getMsg();
        this.data = data;
    }

    public Result(String status, Integer code, String msg, T data) {
        this.status = status;
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    /**
     * 成功结果，返回200，带数据
     * @param data
     * @return
     * @param <T>
     */
    public static <T> Result<T> success(T data) {
        return new Result<>("success", ResponseCodeEnum.CODE_200, data);
    }

    /**
     * 成功响应，返回200，不带数据
     * @return
     */
    public static Result success() {
        return new Result<>("success", ResponseCodeEnum.CODE_200, null);
    }

    /**
     * 失败结果，通过响应状态码枚举构建
     * @param codeEnum
     * @return
     */
    public static Result error(ResponseCodeEnum codeEnum) {
        return new Result<>("error", codeEnum, null);
    }

    /**
     * 失败结果，通过code和msg构建
     * @param code
     * @param msg
     * @return
     */
    public static Result error(Integer code, String msg) {
        return new Result<>("error", code, msg, null);
    }

    /**
     * 失败结果，通过业务异常构建
     * @param e
     * @return
     */
    public static Result error(BusinessException e) {
        return error(e.getCode(), e.getMsg());
    }

    @Override
    public String toString() {
        return "Result{" +
                "status='" + status + '\'' +
                ", code=" + code +
                ", msg='" + msg + '\'' +
                ", data=" + data +
                '}';
    }

    public String getStatus() {
        return status;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public T getData() {
        return data;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```



# 2 mapper

## 2.1 mapper接口

book对应的mapper接口：

```java
@Mapper
public interface BookMapper {

    /**
     * 查询
     *
     * @param 
     * @return
     */
    List<Book> select(@Param("bookQuery") BookQuery bookQuery);

    /**
     * 根据id查询
     *
     * @param 
     * @return
     */
    Book selectById(int id);

    /**
     * 添加
     *
     * @param 
     */
    void insert(Book book);

    /**
     * 批量添加
     * @param 
     */
    void batchInsert(List<Book> books);

    /**
     * 更新
     *
     * @param 
     */
    void update(Book book);

    /**
     * 删除
     *
     * @param 
     */
    void delete(List<Integer> ids);
}
```

## 2.2 对应的xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ling.mappers.BookMapper">
    <!-- 通用查询sql -->
    <sql id="commonSelect">
        select id,
               ISBN,
               name,
               cover,
               author,
               publish,
               publish_date,
               book_type_id,
               description,
               number,
               create_time,
               update_time
    </sql>

    <!-- 条件分页查询 -->
    <select id="select" resultType="com.ling.entity.book.Book" >
        <include refid="commonSelect"/>
        from books
        <where>
            <if test="name != null and name != ''">
                name like concat('%', #{name}, '%')
            </if>
            <if test="author != null and author != ''">
                and author like concat('%', #{author}, '%')
            </if>
            <if test="startDate != null and endDate != null">
                and publish_date between #{startDate} and #{endDate}
            </if>
            <if test="bookTypeId != null">
                and book_type_id = #{bookTypeId}
            </if>
        </where>
    </select>

    <!-- 通过id查询 -->
    <select id="selectById" resultType="com.ling.entity.book.Book">
        <include refid="commonSelect"/>
        from books
        where id = #{id}
    </select>

    <!-- 插入 -->
    <insert id="insert" parameterType="com.ling.entity.book.Book">
        insert into books
        <trim prefix="(" suffix=")" suffixOverrides=",">
            <if test="id != null">id,</if>
            <if test="isbn != null and isbn != ''">ISBN,</if>
            <if test="name != null and name != ''">name,</if>
            <if test="cover != null and cover != ''">cover,</if>
            <if test="author != null and author != ''">author,</if>
            <if test="publish != null and publish != ''">publish,</if>
            <if test="publishDate != null">publish_date,</if>
            <if test="bookTypeId != null">book_type_id,</if>
            <if test="description != null and description != ''">description,</if>
            <if test="number != null">number,</if>
            <if test="createTime != null">create_time,</if>
            <if test="updateTime != null">update_time,</if>
        </trim>
        <trim prefix="values (" suffix=")" suffixOverrides=",">
            <if test="id != null">#{id},</if>
            <if test="isbn != null and isbn != ''">#{isbn},</if>
            <if test="name != null and name != ''">#{name},</if>
            <if test="cover != null and cover != ''">#{cover},</if>
            <if test="author != null and author != ''">#{author},</if>
            <if test="publish != null and publish != ''">#{publish},</if>
            <if test="publishDate != null">#{publishDate},</if>
            <if test="bookTypeId != null">#{bookTypeId},</if>
            <if test="description != null and description != ''">#{description},</if>
            <if test="number != null">#{number},</if>
            <if test="createTime != null">#{createTime},</if>
            <if test="updateTime != null">#{updateTime},</if>
        </trim>
    </insert>

    <!-- 批量插入 -->
    <insert id="batchInsert">
        insert into books
        <trim prefix="(" suffix=")" suffixOverrides=",">
            /* 方法形参是集合，类型集合中的元素，因此取出第一个元素 */
            <if test="books[0].id != null">id,</if>
            <if test="books[0].isbn != null and books[0].isbn != ''">ISBN,</if>
            <if test="books[0].name != null and books[0].name != ''">name,</if>
            <if test="books[0].cover != null and books[0].cover != ''">cover,</if>
            <if test="books[0].author != null and books[0].author != ''">author,</if>
            <if test="books[0].publish != null and books[0].publish != ''">publish,</if>
            <if test="books[0].publishDate != null">publish_date,</if>
            <if test="books[0].bookTypeId != null">book_type_id,</if>
            <if test="books[0].description != null and books[0].description != ''">description,</if>
            <if test="books[0].number != null">number,</if>
            <if test="books[0].createTime != null">create_time,</if>
            <if test="books[0].updateTime != null">update_time,</if>
        </trim>
        values
        <foreach collection="books" item="book" separator=",">
            <trim prefix="(" suffix=")" suffixOverrides=",">
                <if test="book.id != null">#{book.id},</if>
                <if test="book.isbn != null and book.isbn != ''">#{book.isbn},</if>
                <if test="book.name != null and book.name != ''">#{book.name},</if>
                <if test="book.cover != null and book.cover != ''">#{book.cover},</if>
                <if test="book.author != null and book.author != ''">#{book.author},</if>
                <if test="book.publish != null and book.publish != ''">#{book.publish},</if>
                <if test="book.publishDate != null">#{book.publishDate},</if>
                <if test="book.bookTypeId != null">#{book.bookTypeId},</if>
                <if test="book.description != null and book.description != ''">#{book.description},</if>
                <if test="book.number != null">#{book.number},</if>
                <if test="book.createTime != null">#{book.createTime},</if>
                <if test="book.updateTime != null">#{book.updateTime},</if>
            </trim>
        </foreach>
    </insert>

    <!-- 更新 -->
    <update id="update">

    </update>

    <update id="batchUpdate">

    </update>

    <!-- 删除/批量删除 -->
    <delete id="delete"></delete>
</mapper>
```



# 3 service

## 3.1 接口

```java
public interface BookService {

    /**
     * 条件分页查询
     * @param bookQuery
     * @return
     */
    PageBean<Book> find(BookQuery bookQuery);

    /**
     * 根据id查询
     * @param id
     * @return
     */
    Book findById(Integer id);

    /**
     * 新增
     * @param book
     */
    void add(Book book);

    /**
     * 批量新增
     * @param books
     */
    void batchAdd(List<Book> books);

    /**
     * 修改
     * @param book
     */
    void edit(Book book);

    /**
     * 删除/批量删除
     * @param ids
     */
    void delete(List<Integer> ids);
}
```

## 3.2 实现

分页采用PageHelper插件。

```java
@Service
public class BookServiceImpl implements BookService {
    @Resource
    private BookMapper bookMapper;

    @Override
    public PageBean<Book> find(BookQuery bookQuery) {
        PageHelper.startPage(bookQuery.getPage(), bookQuery.getPageSize());
        List<Book> books = bookMapper.select(bookQuery);
        Page<Book> p = (Page<Book>) books;
        if (bookQuery.getPage() > p.getPages()) throw new BusinessException(ResponseCodeEnum.CODE_600);
        return PageBean.of(p.getTotal(), bookQuery.getPage(), bookQuery.getPageSize(), p.getPages(), p.getResult());
    }

    @Override
    public Book findById(Integer id) {
        return bookMapper.selectById(id);
    }

    @Override
    public void add(Book book) {
        bookMapper.insert(book);
    }

    @Override
    public void batchAdd(List<Book> books) {

    }

    @Override
    public void edit(Book book) {
        bookMapper.update(book);
    }

    @Override
    public void delete(List<Integer> ids) {
        bookMapper.delete(ids);
    }
}
```



# 4 controller

## 4.1 控制器

```java
@RestController
@RequestMapping("/book")
public class BookController {
    @Resource
    private BookService bookService;

    @GetMapping
    public Result<PageBean<Book>> getBookInfo(@RequestBody BookQuery bookQuery) {
        System.out.println(bookQuery);
        PageBean<Book> pageBean = bookService.find(bookQuery);
        return Result.success(pageBean);
    }
}
```

## 4.2 统一异常拦截器

```java
@RestControllerAdvice
public class GlobalExceptionController {
    private Logger log = LoggerFactory.getLogger(GlobalExceptionController.class);

    /**
     * 业务异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(BusinessException.class)
    public Result businessExceptionHandler(BusinessException e) {
        log.info("异常：{}，异常信息：{}", e, e.getMsg());
        return Result.error(e);
    }

    /**
     * 404异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(NoHandlerFoundException.class)
    public Result exceptionHandler404(NoHandlerFoundException e) {
        log.error("异常：{}，异常信息：{}", e, e.getMessage());
        return Result.error(ResponseCodeEnum.CODE_404);
    }

    /**
     * 请求参数异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler({MissingServletRequestParameterException.class,
            BindException.class})
    public Result exceptionHandler600(Exception e) {
        log.error("异常：{}，异常信息：{}", e, e.getMessage());
        return Result.error(ResponseCodeEnum.CODE_600);
    }

    /**
     * 主键冲突异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(DuplicateKeyException.class)
    public Result exceptionHandler601(DuplicateKeyException e) {
        log.error("异常：{}，异常信息：{}", e, e.getMessage());
        return Result.error(ResponseCodeEnum.CODE_601);
    }

    /**
     * 其他异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(Exception.class)
    public Result exceptionHandler500(Exception e) {
        log.error("异常：{}，异常信息：{}", e, e.getMessage());
        return Result.error(ResponseCodeEnum.CODE_500);
    }
}
```

